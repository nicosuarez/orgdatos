#include <iostream>
#include <string>
#include <cstring>
#include <ctime>    // For time()
#include <cstdlib>  // For srand() and rand()

#include "../bpptree.h"
#include "../bppIterator.h"
#include "../register_pack.h"

using namespace bpptree;

class KeyKeyVal : public Register{
	private:
		std::string key;
	public:
		KeyKeyVal(const std::string& key){
			this->key = key;
		}
		KeyKeyVal(const KeyKeyVal& k2){
			this->key = k2.getKey();
		}
		
		std::string getKey()const{ return this->key;  }

		Register* duplicate()const{
			return (new KeyKeyVal(*this));
		}

		void setFields(const Register& b2){
			const KeyKeyVal& temp = dynamic_cast<const KeyKeyVal&>(b2);
			this->key = temp.getKey();
		}

		unsigned int getSize()const {
			return (sizeof(char)*20);
		};

		bool operator<(const Register& b2)const{
			const KeyKeyVal& temp = dynamic_cast<const KeyKeyVal&>(b2);
			bool ret = false;
			if((this->key).compare(temp.getKey())<0)
				ret = true;

			return ret;
		}

		std::ostream& toOstream(std::ostream& out)const{
			out << this->key;
			return out;
		}
};


class KeyKeyValFactory : public RegisterFactory{
	public:
		KeyKeyValFactory(){}
		~KeyKeyValFactory(){}

		RegisterFactory* duplicate()const{ return new KeyKeyValFactory(); }

		Register* operator ()(char* data)const{
			char* temp = data;
			char keyTemp[20];
			memset(keyTemp,0,sizeof(char)*20);
			memcpy(keyTemp,temp,sizeof(char)*20);
			temp += sizeof(char)*20;
			return (new KeyKeyVal(std::string(keyTemp)));
		}
		
		char* operator ()(const Register& reg,char* data)const{
			const KeyKeyVal& kvreg = dynamic_cast<const KeyKeyVal&>(reg);
			char* temp = data;
			char tempKey[20];
			memset(tempKey,0,sizeof(char)*20);
			memcpy(tempKey,kvreg.getKey().c_str(),kvreg.getKey().length());
			memcpy(temp,tempKey,sizeof(char)*20);
			temp+=sizeof(char)*20;
			return temp;
		}
};


class KeyVal : public Register{
	private:
		std::string key;
		unsigned int value;
	public:
		KeyVal(const std::string& key,unsigned int value){
			this->key   = key;
			this->value = value;
		}
		KeyVal(const KeyVal& k2){
			this->key   = k2.getKey();
			this->value = k2.getValue();
		}
	

		std::string getKey()const{ return this->key;  }
		unsigned int getValue()const{ return this->value; }

		Register* duplicate()const{
			return (new KeyVal(*this));
		}

		void setFields(const Register& b2){
			const KeyVal& temp = dynamic_cast<const KeyVal&>(b2);
			this->key = temp.getKey();
			this->value = temp.getValue();
		}

		unsigned int getSize()const {
			return (sizeof(unsigned int)+sizeof(char)*20);
		};

		bool operator<(const Register& b2)const{
			const KeyVal& temp = dynamic_cast<const KeyVal&>(b2);
			bool ret = false;
			if((this->key).compare(temp.getKey())<0)
				ret = true;

			return ret;
		}

		std::ostream& toOstream(std::ostream& out)const{
			out << "\t\t Key   : " << this->key << std::endl;
			out << "\t\t Value : " << this->value << std::endl;
			return out;
		}
		
		virtual Register* getKeyRegister()const {
			KeyKeyVal* reg = new KeyKeyVal(this->key);
			return reg;
		}
};


class KeyValFactory : public RegisterFactory{
	public:
		KeyValFactory(){}
		~KeyValFactory(){}

		RegisterFactory* duplicate()const{ return new KeyValFactory(); }

		Register* operator ()(char* data)const{
			char* temp = data;
			char keyTemp[20];
			unsigned int tempVal;
			memset(keyTemp,0,sizeof(char)*20);
			memcpy(keyTemp,temp,sizeof(char)*20);
			temp += sizeof(char)*20;
			memcpy(&tempVal,temp,sizeof(unsigned int));
			return (new KeyVal(std::string(keyTemp),tempVal));
		}
		
		char* operator ()(const Register& reg,char* data)const{
			const KeyVal& kvreg = dynamic_cast<const KeyVal&>(reg);
			char* temp = data;
			char tempKey[20];
			unsigned int tempValue = kvreg.getValue();
			memset(tempKey,0,sizeof(char)*20);
			memcpy(tempKey,kvreg.getKey().c_str(),kvreg.getKey().length());
			memcpy(temp,tempKey,sizeof(char)*20);
			temp+=sizeof(char)*20;
			memcpy(temp,&tempValue,sizeof(unsigned int));
			temp+=sizeof(unsigned int);
			return temp;
		}
};


#define cantReg 150 


int main(){
	KeyValFactory kvf;
	KeyKeyValFactory kkvf;
	BppTree bpptree(256,kvf,kkvf,"bpptree.dat");
	
	std::string vec[cantReg];

	char c;
	srand( (unsigned int) time(NULL));

	for(int k = 0; k<cantReg; k++){
		/*GENERO STRING CON CLAVE*/
		char* line = new char[5];
	
		for(int a = 0; a<4; a++){
	
			c=((rand() % 26) + 'a');
			line[a] = c;
		} 
		line[4]='\0';
		std::string st(line); 
		delete []line;

		int i = 0;
		bool encontro = false;
		while((i<k)&&(!encontro)){
			if(st.compare(vec[i])==0)	
				encontro = true;
			i++;
		}
		if(!encontro){
			vec[k] = st;
			/*GUARDO CLAVE EN ARBOL B+*/
			KeyVal kv4(st,k);
			bpptree.insert(kv4);
		}
		else
			k--;
	}

	
	std::cout << bpptree;
	
//	std::cout << bpptree;
	
/*	int u = 0;
	while(u<200){
		if(!(bppIter->EndOfFile())){
			Register* regi = bppIter->getRegister();
			regi->toOstream(std::cout);
			delete regi;
			bppIter->sig();
		}
		u++;
	}

	if((bppIter->EndOfFile())){
		bppIter->ant();
	}

	u = 0;
	while(u<20){
		if(!(bppIter->BeginOfFile())){
			Register* regi = bppIter->getRegister();
			regi->toOstream(std::cout);
			delete regi;
			bppIter->ant();
		}
		u++;
	}*/
		
	/*for(int k = 0; k<50; k++){
		
		int n;
		n=((rand() % (cantReg-1)) + 1);
	
		
		std::cout<<"reg eliminado: "<<n<<" (key= "<<vec[n]<<")\n";
		KeyVal kv4(vec[n],0);
		bpptree.remove(kv4);

	}*/

	//std::cout << bpptree;
/*
	BppIterator* bppIter = NULL;
	int cont = 0;
	while((bppIter==NULL)&&(cont<cantReg)){
		KeyVal kv4(vec[cont],4);
		bppIter = bpptree.getBppIterator(kv4);
		cont++;
	}

	int u = 0;
	while(u<200){
		if(!(bppIter->EndOfFile())){
			Register* regi = bppIter->getRegister();
			//regi->toOstream(std::cout);
			delete regi;
			bppIter->sig();
		}
		u++;
	}

/*	if((bppIter->EndOfFile())){
		bppIter->ant();
	}
	int cont2 = 0;
	u = 0;
	while(u<2000){
		if(!(bppIter->BeginOfFile())){
			cont2++;
			Register* regi = bppIter->getRegister();
			regi->toOstream(std::cout);
			delete regi;
			bppIter->ant();
			if((bppIter->BeginOfFile())){
				Register* regi2 = bppIter->getRegister();
				regi2->toOstream(std::cout);
				delete regi2;
				cont2++;
			}
		}
		u++;
	}
	std::cout<<"CantRegFinal: "<<cont2<<"\n";
	delete bppIter;*/
	return 0;
} 
